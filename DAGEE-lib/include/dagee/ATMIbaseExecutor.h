// Copyright (c) 2018-Present Advanced Micro Devices, Inc. See LICENSE.TXT for terms.

#ifndef DAGEE_INCLUDE_DAGEE_ATMI_EXECUTOR_BASE_H
#define DAGEE_INCLUDE_DAGEE_ATMI_EXECUTOR_BASE_H

#include "dagee/ATMIcoreDef.h"

#include "atmi.h"
#include "atmi_runtime.h"

#include <initializer_list>

namespace dagee {

/**
 * Provides access to private methods of the executor
 */
template <typename Exec>
struct ExecutorAccess {
  Exec* mExec;

  template <typename TaskInstance, typename V = std::initializer_list<ATMItaskHandle>>
  ATMItaskHandle makeInternalTask(const TaskInstance& ti, const V& predHandles = V()) {
    return mExec->makeInternalTask(ti, predHandles);
  }
};

namespace impl {
template <typename Exec, typename V = std::initializer_list<ATMItaskHandle>>
ATMItaskHandle makeInternalTaskForDag(Exec* execPtr, const typename Exec::TaskInstance& ti,
                                      const V& predHandles = V()) {
  ExecutorAccess<Exec> ea{execPtr};
  return ea.makeInternalTask(ti, predHandles);
}
} // namespace impl

/**
 * This class defines the minimally necessary interface of an Executor
 */
struct HypotheticalExecutor {
  /**
   * This class represents instance of a task generated by this executor
   */
  class HypotheticalTaskInstance {};

  /**
   * Must expose a public typename TaskInstance
   */
  using TaskInstance = HypotheticalTaskInstance;

 private:
  /**
   * a private method to create an internal ATMI task from a TaskInstance
   */
  template <typename V = std::initializer_list<ATMItaskHandle>>
  ATMItaskHandle makeInternalTask(const TaskInstance& ti, const V& predHandles = V()) {
    return ATMItaskHandle{};
  }

  /**
   * Must have this friend declaration which allows access to makeInternalTask
   */
  template <typename>
  friend struct ExecutorAccess;

 public:
  /**
   * A method to create a TaskInstance
   */
  template <typename... Args>
  TaskInstance makeTask(Args&&...) const {
    return TaskInstance{};
  }

  /**
   * A method to launch a TaskInstance that can take a vector like container of
   * predecessors that this task depends on. By default users can pass an
   * initializer_list by typing: executor.launchTask(executor.makeTask(args), {predA, predB,
   * predC});
   */
  template <typename V = std::initializer_list<ATMItaskHandle>>
  ATMItaskHandle launchTask(const TaskInstance& ti, const V& predecessors) {
    return ATMItaskHandle{};
  }
};

class InitAtmiBase {
  void init() { CHECK_ATMI(atmi_init(ATMI_DEVTYPE_ALL)); }
  void finish() { /*atmi_finalize();*/
  } // TODO(amber/ashwin) FIXME: this causes a crash when invoked multiple times by different
    // derived instances

 public:
  InitAtmiBase() { init(); }
  ~InitAtmiBase() { finish(); }
};

template <typename KernelRegPolicy, typename TaskLaunchPolicy>
struct ExecutorSkeletonAtmi : public InitAtmiBase, public KernelRegPolicy, public TaskLaunchPolicy {
  using TaskInstance = typename TaskLaunchPolicy::TaskInstance;
  using KernelInfo = typename KernelRegPolicy::KernelInfo;

 protected:
  // make non-copyable or assignable
  ExecutorSkeletonAtmi(const ExecutorSkeletonAtmi&) = delete;
  ExecutorSkeletonAtmi& operator=(const ExecutorSkeletonAtmi&) = delete;

  // disabling move operations for now as well
  ExecutorSkeletonAtmi(ExecutorSkeletonAtmi&&) = delete;
  ExecutorSkeletonAtmi& operator=(ExecutorSkeletonAtmi&&) = delete;

  template <typename>
  friend struct ExecutorAccess;

  // TODO(amber): receive TaskInstance as const ref here. It's currently non-const
  // reft due to the need to update the mATMItaskHandle field of TaskInstance. This
  // is only needed by DAG executors today. We can embed the mATMItaskHandle in a new
  // class that inherits from TaskInstance
  template <typename V = std::vector<ATMItaskHandle>>
  ATMItaskHandle makeInternalTask(const TaskInstance& ti, const V& predHandles = V()) const {
    static_assert(std::is_same<typename V::value_type, ATMItaskHandle>::value,
                  "predHandles has the wrong type");

    return TaskLaunchPolicy::makeInternalTask(ti, predHandles.data(), predHandles.size());
  }

 public:
  ExecutorSkeletonAtmi() : InitAtmiBase(), KernelRegPolicy(), TaskLaunchPolicy() {}

  template <typename V = std::initializer_list<ATMItaskHandle>>
  ATMItaskHandle launchTask(const TaskInstance& ti, const V& predHandles = V()) const {
    static_assert(std::is_same<typename V::value_type, ATMItaskHandle>::value,
                  "predHandles has the wrong type");
    return TaskLaunchPolicy::launchInternalTask(ti, predHandles.begin(), predHandles.size());
  }

  template <typename I>
  void waitOnTasks(const I& taskHbeg, const I& taskHend) const {
    impl::waitOnTasks(taskHbeg, taskHend);
  }

  void waitOnTasks(std::initializer_list<ATMItaskHandle> l) const { impl::waitOnTasks(l); }

  void waitOnTask(const ATMItaskHandle& t) const { impl::waitOnTask(t); }
};

} // end namespace dagee

#endif // DAGEE_INCLUDE_DAGEE_ATMI_EXECUTOR_BASE_H
